<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js canvas - camera - orthographic</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css"/>
</head>
<body>

<div id="container"></div>
<script src="three.min.js"></script>

<script id="sharedShaderCode" type="x-shader/x-fragment">
int getParticleIndex(vec2 uv, vec2 size) {
    ivec2 coord = ivec2(floor(uv*size+0.5));
    return coord.x + int(size.x) * coord.y;
}
vec2 getParticleUV(float particleIndex, vec2 res){
    vec2 particleUV = vec2(mod(particleIndex/res.x,1.0), floor( particleIndex/res.y ) / res.x);
    return particleUV;
}
// Get grid position as a vec3: (xIndex, yIndex, zIndex)
vec3 worldPosToGridPos(vec3 particlePos, vec3 gridPos, vec3 cellSize){
    return floor((particlePos - gridPos)/cellSize);
}
// Convert grid position to UV coord in the grid texture
vec2 gridPosToGridUV(vec3 gridPos, int subIndex, vec3 gridRes){
    gridPos = clamp(gridPos, vec3(0), gridRes-1.0); // Keep within limits
    vec2 gridTexRes = 2.0 * gridRes.xy * vec2(1, gridRes.z);
    vec2 gridUV = 2.0 * gridPos.xy / gridTexRes;
    gridUV.y += gridPos.z / gridRes.z; // Move up to correct z section
    // Choose sub pixel
    float fSubIndex = float(subIndex);
    gridUV += vec2(mod(fSubIndex,2.0), fSubIndex/2.0) / gridTexRes;
    //gridUV += vec2(1)/gridTexRes; // Move to center of pixel
    return gridUV;
}
vec2 gridPosToGridUV2(vec3 gridPos, int subIndex, vec3 gridRes){
    float fGridPotZ = float(gridPotZ);

    gridPos = clamp(gridPos, vec3(0), gridRes-vec3(1)); // Keep within limits

    vec2 gridTexRes = gridRes.xy * vec2(fGridPotZ * 2.0);
    vec2 gridUV = 2.0 * gridPos.xy / vec2(gridTexRes);

    // move to correct z square
    vec2 zPos = vec2( mod(gridPos.z, fGridPotZ), floor(gridPos.z / fGridPotZ) );
    zPos /= vec2(fGridPotZ);
    gridUV += zPos;

    // Choose sub pixel
    float fSubIndex = float(subIndex);
    gridUV += vec2( mod(fSubIndex,2.0), floor(fSubIndex/2.0) ) / gridTexRes;

    return gridUV;
}

</script>
<script id="vertexShader" type="x-shader/x-vertex">
void main() {
    gl_Position = vec4( position, 1.0 );
}
</script>
<script id="testFrag" type="x-shader/x-fragment">
uniform sampler2D texture;
void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    gl_FragColor = texture2D( texture, uv );
}
</script>
<script id="mapParticleToCellVert" type="x-shader/x-vertex">
uniform sampler2D posTex;
uniform vec3 cellSize;
uniform vec3 gridPos;
attribute float particleIndex;
varying float vParticleIndex;
void main() {
    vParticleIndex = particleIndex;
    vec2 particleUV = getParticleUV(particleIndex, resolution);
    vec3 particlePos = texture2D( posTex, particleUV ).xyz;
    // Get particle cell position
    vec3 cellPos = worldPosToGridPos(particlePos, gridPos, cellSize);
    vec2 gridUV = gridPosToGridUV2(cellPos, 0, gridResolution);
    vec2 gridTexRes = 2.0 * gridResolution.xy * vec2(gridPotZ);
    gridUV += vec2(1) / gridTexRes;// center to cell
    gl_PointSize = 2.0; // Cover 4 pixels in the grid texture
    gl_Position = vec4(2.0*(gridUV-0.5), 0, 1);
}
</script>
<script id="mapParticleToCellFrag" type="x-shader/x-fragment">
varying float vParticleIndex;
void main() {
    gl_FragColor = vec4( vParticleIndex+1.0, 0, 0, 1 ); // indices are stored incremented by 1
}
</script>
<script id="updateForceFrag" type="x-shader/x-fragment">
uniform vec4 params1;
#define stiffness params1.x
#define damping params1.y
#define radius params1.z
#define drag params1.w

uniform vec3 gravity;
uniform vec3 cellSize;
uniform vec3 gridPos;

uniform sampler2D posTex;
uniform sampler2D velTex;
uniform sampler2D gridTex;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    int particleIndex = getParticleIndex(uv, resolution);

    // Get id and position of current
    vec3 position = texture2D(posTex, uv).xyz;
    vec3 velocity = texture2D(velTex, uv).xyz;
    vec3 particleGridPos = worldPosToGridPos(position, gridPos, cellSize);

    vec3 force = gravity;
    ivec3 iGridRes = ivec3(gridResolution);
    vec2 gridTexRes = 2.0 * gridResolution.xy * vec2(gridPotZ);

    // Neighbor collisions
    for(int i=-1; i<2; i++){
        for(int j=-1; j<2; j++){
            for(int k=-1; k<2; k++){
                vec3 neighborCellGridPos = particleGridPos + vec3(i,j,k);
                ivec3 iNeighborCellGridPos = ivec3(particleGridPos) + ivec3(i,j,k);
                for(int l=0; l<4; l++){
                    vec2 neighborCellTexUV = gridPosToGridUV2(neighborCellGridPos, l, gridResolution);
                    neighborCellTexUV += vec2(0.5) / (2.0 * gridTexRes); // center to "cell pixel"
                    int neighborIndex = int(floor(texture2D(gridTex, neighborCellTexUV).x-1.0 + 0.5)); // indices are stored incremented by 1
                    vec2 neighborUV = getParticleUV(float(neighborIndex), resolution);
                    vec3 neighborPosition = texture2D(posTex, neighborUV).xyz;
                    vec3 neighborVelocity = texture2D(velTex, neighborUV).xyz;
                    if(neighborIndex >=0 && neighborIndex != particleIndex && iNeighborCellGridPos.x>=0 && iNeighborCellGridPos.y>=0 && iNeighborCellGridPos.z>=0 && iNeighborCellGridPos.x<iGridRes.x && iNeighborCellGridPos.y<iGridRes.y && iNeighborCellGridPos.z<iGridRes.z){ // Not self!
                        // Apply contact force from neighbor
                        vec3 r = position - neighborPosition;
                        float len = length(r);
                        if(len > 0.0 && len < radius * 2.0){
                            vec3 dir = normalize(r);
                            force -= stiffness * (len - 2.0 * radius) * dir + damping * dot(velocity, dir) * dir;
                        }

                        // TODO: Apply shear (tangential) force - this probably needs to be done in other pass
                    }
                }
            }
        }
    }

    // Apply force from ground / bounds?
    vec3 boxMax = vec3(0.7);
    vec3 boxMin = vec3(0.3);
    if(position.x - radius < boxMin.x){
        float x = position.x - radius;
        float x0 = boxMin.x;
        force.x -= stiffness * (x - x0) + damping * velocity.x;
    }
    if(position.y - radius < boxMin.y){
        float x = position.y - radius;
        float x0 = boxMin.y;
        force.y -= stiffness * (x - x0) + damping * velocity.y;
    }
    if(position.z - radius < boxMin.z){
        float x = position.z - radius;
        float x0 = boxMin.z;
        force.z -= stiffness * (x - x0) + damping * velocity.z;
    }
    if(position.x + radius > boxMax.x){
        float x = position.x + radius;
        float x0 = boxMax.x;
        force.x -= stiffness * (x - x0) + damping * velocity.x;
    }
    if(position.y + radius > boxMax.y){
        float x = position.y + radius;
        float x0 = boxMax.y;
        force.y -= stiffness * (x - x0) + damping * velocity.y;
    }
    if(position.z + radius > boxMax.z){
        float x = position.z + radius;
        float x0 = boxMax.z;
        force.z -= stiffness * (x - x0) + damping * velocity.z;
    }

    // "Air friction" / drag force
    force -= drag * velocity;

    gl_FragColor = vec4(force, 0.0);
}
</script>
<script id="updateVelocityFrag" type="x-shader/x-fragment">
uniform sampler2D velTex;
uniform sampler2D forceTex;
uniform vec4 params2;
#define deltaTime params2.x

void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec4 velocity = texture2D(velTex, uv);
    vec4 force = texture2D(forceTex, uv);
    //float invMass = velocity.w;
    gl_FragColor = vec4(velocity.xyz + force.xyz * deltaTime, 1.0);
}
</script>
<script id="updatePositionFrag" type="x-shader/x-fragment">
uniform sampler2D posTex;
uniform sampler2D velTex;
uniform vec4 params2;
#define deltaTime params2.x

void main() {
   vec2 uv = gl_FragCoord.xy / resolution.xy;
   vec3 velocity = texture2D(velTex, uv).xyz;
   vec3 position = texture2D(posTex, uv).xyz;
   gl_FragColor = vec4(position + velocity * deltaTime, 1.0);
}
</script>

<script src="three.orbitcontrols.js"></script>
<script src="main.js"></script>
</body>
</html>