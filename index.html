<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js canvas - camera - orthographic</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css"/>
</head>
<body>

<div id="container"></div>
<script src="three.min.js"></script>

<script id="sharedShaderCode" type="x-shader/x-fragment">
int uvToIndex(vec2 uv, vec2 size) {
    ivec2 coord = ivec2(floor(uv*size+0.5));
    return coord.x + int(size.x) * coord.y;
}
vec2 indexToUV(float index, vec2 res){
    vec2 particleUV = vec2(mod(index/res.x,1.0), floor( index/res.y ) / res.x);
    return particleUV;
}
// Get grid position as a vec3: (xIndex, yIndex, zIndex)
vec3 worldPosToGridPos(vec3 particlePos, vec3 gridPos, vec3 cellSize){
    return floor((particlePos - gridPos)/cellSize);
}
// Convert grid position to UV coord in the grid texture
vec2 gridPosToGridUV(vec3 gridPos, int subIndex, vec3 gridRes){
    gridPos = clamp(gridPos, vec3(0), gridRes-1.0); // Keep within limits
    vec2 gridTexRes = 2.0 * gridRes.xy * vec2(1, gridRes.z);
    vec2 gridUV = 2.0 * gridPos.xy / gridTexRes;
    gridUV.y += gridPos.z / gridRes.z; // Move up to correct z section
    // Choose sub pixel
    float fSubIndex = float(subIndex);
    gridUV += vec2(mod(fSubIndex,2.0), fSubIndex/2.0) / gridTexRes;
    return gridUV;
}
vec2 gridPosToGridUV2(vec3 gridPos, int subIndex, vec3 gridRes){
    float fGridPotZ = float(gridPotZ);

    gridPos = clamp(gridPos, vec3(0), gridRes-vec3(1)); // Keep within limits

    vec2 gridTexRes = gridRes.xy * vec2(fGridPotZ * 2.0);
    vec2 gridUV = 2.0 * gridPos.xy / vec2(gridTexRes);

    // move to correct z square
    vec2 zPos = vec2( mod(gridPos.z, fGridPotZ), floor(gridPos.z / fGridPotZ) );
    zPos /= vec2(fGridPotZ);
    gridUV += zPos;

    // Choose sub pixel
    float fSubIndex = float(subIndex);
    gridUV += vec2( mod(fSubIndex,2.0), floor(fSubIndex/2.0) ) / gridTexRes;

    return gridUV;
}
// Integrate a quaternion using an angular velocity and deltatime
vec4 quat_integrate(vec4 q, vec3 w, float dt){
    float half_dt = dt * 0.5;

    q.x += half_dt * (w.x * q.w + w.y * q.z - w.z * q.y); // TODO: vectorize
    q.y += half_dt * (w.y * q.w + w.z * q.x - w.x * q.z);
    q.z += half_dt * (w.z * q.w + w.x * q.y - w.y * q.x);
    q.w += half_dt * (- w.x * q.x - w.y * q.y - w.z * q.z);

    return normalize(q);
}

// Rotate a vector by a quaternion
vec3 vec3_applyQuat(vec3 v, vec4 q){
    float ix =  q.w * v.x + q.y * v.z - q.z * v.y; // TODO: vectorize
    float iy =  q.w * v.y + q.z * v.x - q.x * v.z;
    float iz =  q.w * v.z + q.x * v.y - q.y * v.x;
    float iw = -q.x * v.x - q.y * v.y - q.z * v.z;

    return vec3(
        ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y,
        iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z,
        iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x
    );
}

</script>
<script id="vertexShader" type="x-shader/x-vertex">
void main() {
    gl_Position = vec4( position, 1.0 );
}
</script>
<script id="testFrag" type="x-shader/x-fragment">
uniform sampler2D texture;
void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    gl_FragColor = texture2D( texture, uv );
}
</script>
<script id="mapParticleToCellVert" type="x-shader/x-vertex">
uniform sampler2D posTex;
uniform vec3 cellSize;
uniform vec3 gridPos;
attribute float particleIndex;
varying float vParticleIndex;
void main() {
    vParticleIndex = particleIndex;
    vec2 particleUV = indexToUV(particleIndex, resolution);
    vec3 particlePos = texture2D( posTex, particleUV ).xyz;
    // Get particle cell position
    vec3 cellPos = worldPosToGridPos(particlePos, gridPos, cellSize);
    vec2 gridUV = gridPosToGridUV2(cellPos, 0, gridResolution);
    vec2 gridTexRes = 2.0 * gridResolution.xy * vec2(gridPotZ);
    gridUV += vec2(1) / gridTexRes;// center to cell
    gl_PointSize = 2.0; // Cover 4 pixels in the grid texture
    gl_Position = vec4(2.0*(gridUV-0.5), 0, 1);
}
</script>
<script id="mapParticleToCellFrag" type="x-shader/x-fragment">
varying float vParticleIndex;
void main() {
    gl_FragColor = vec4( vParticleIndex+1.0, 0, 0, 1 ); // indices are stored incremented by 1
}
</script>
<script id="updateForceFrag" type="x-shader/x-fragment">
uniform vec4 params1;
#define stiffness params1.x
#define damping params1.y
#define radius params1.z
#define drag params1.w
uniform vec4 params2;
#define friction params2.y

uniform vec3 gravity;
uniform vec3 cellSize;
uniform vec3 gridPos;

uniform sampler2D posTex;
uniform sampler2D velTex;
uniform sampler2D gridTex;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    int particleIndex = uvToIndex(uv, resolution);

    // Get id and position of current
    vec3 position = texture2D(posTex, uv).xyz;
    vec3 velocity = texture2D(velTex, uv).xyz;
    vec3 particleGridPos = worldPosToGridPos(position, gridPos, cellSize);

    vec3 force = gravity;
    ivec3 iGridRes = ivec3(gridResolution);
    vec2 gridTexRes = 2.0 * gridResolution.xy * vec2(gridPotZ);

    // Neighbor collisions
    for(int i=-1; i<2; i++){
        for(int j=-1; j<2; j++){
            for(int k=-1; k<2; k++){
                vec3 neighborCellGridPos = particleGridPos + vec3(i,j,k);
                ivec3 iNeighborCellGridPos = ivec3(particleGridPos) + ivec3(i,j,k);
                for(int l=0; l<4; l++){
                    vec2 neighborCellTexUV = gridPosToGridUV2(neighborCellGridPos, l, gridResolution);
                    neighborCellTexUV += vec2(0.5) / (2.0 * gridTexRes); // center to "cell pixel"
                    int neighborIndex = int(floor(texture2D(gridTex, neighborCellTexUV).x-1.0 + 0.5)); // indices are stored incremented by 1
                    vec2 neighborUV = indexToUV(float(neighborIndex), resolution);
                    vec3 neighborPosition = texture2D(posTex, neighborUV).xyz;
                    vec3 neighborVelocity = texture2D(velTex, neighborUV).xyz;
                    if(neighborIndex >=0 && neighborIndex != particleIndex && iNeighborCellGridPos.x>=0 && iNeighborCellGridPos.y>=0 && iNeighborCellGridPos.z>=0 && iNeighborCellGridPos.x<iGridRes.x && iNeighborCellGridPos.y<iGridRes.y && iNeighborCellGridPos.z<iGridRes.z){ // Not self!
                        // Apply contact force from neighbor
                        vec3 r = position - neighborPosition;
                        float len = length(r);
                        if(len > 0.0 && len < radius * 2.0){
                            vec3 dir = normalize(r);
                            force -= stiffness * (len - 2.0 * radius) * dir + damping * dot(velocity, dir) * dir;

                            // Compute shear (tangential) force - this won't make sense until bodies are implemented
                            vec3 relVel = velocity - neighborVelocity;
                            vec3 relTangentVel = relVel - dot(relVel, dir) * dir;
                            //force -= friction * relTangentVel;
                        }
                    }
                }
            }
        }
    }

    // Apply force from ground / bounds
    vec3 boxMin = vec3(0.3);
    vec3 boxMax = vec3(0.7);
    vec3 x = position - radius;
    vec3 f = - stiffness * (x - boxMin) - damping * velocity;
    force += step(x, boxMin) * f;
    x = position + radius;
    f = - stiffness * (x - boxMax) - damping * velocity;
    force += step(boxMax, x) * f;

    // "Air friction" / drag force
    force -= drag * velocity;

    gl_FragColor = vec4(force, 0.0);
}
</script>
<script id="updateVelocityFrag" type="x-shader/x-fragment">
// Should be possible to use for both angular and linear velocity
uniform sampler2D velTex;
uniform sampler2D forceTex;
uniform vec4 params2;
#define deltaTime params2.x

void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec4 velocity = texture2D(velTex, uv);
    vec4 force = texture2D(forceTex, uv);
    gl_FragColor = vec4(velocity.xyz + force.xyz * deltaTime, 1.0);
}
</script>
<script id="updatePositionFrag" type="x-shader/x-fragment">
uniform sampler2D posTex;
uniform sampler2D velTex;
uniform vec4 params2;
#define deltaTime params2.x

void main() {
   vec2 uv = gl_FragCoord.xy / resolution;
   vec3 position = texture2D(posTex, uv).xyz;
   vec3 velocity = texture2D(velTex, uv).xyz;
   gl_FragColor = vec4(position + velocity * deltaTime, 1.0);
}
</script>
<script id="updateQuaternionFrag" type="x-shader/x-fragment">
uniform sampler2D quatTex;
uniform sampler2D angularVelTex;
uniform vec4 params2;
#define deltaTime params2.x

void main() {
   vec2 uv = gl_FragCoord.xy / resolution;
   vec3 quat = texture2D(quatTex, uv).xyz;
   vec3 angularVel = texture2D(angularVelTex, uv).xyz;
   gl_FragColor = quat_integrate(quat, angularVel, deltaTime);
}
</script>

<!-- rendered additively with GL_POINTS to a body force texture -->
<script id="addParticleForceToBodyVert" type="x-shader/x-vertex">
uniform sampler2D relativeParticlePosTex;
uniform sampler2D particleForceTex;
attribute float particleIndex;
attribute float bodyIndex; // Should this be in a texture?
varying vec3 vBodyForce;
void main() {
    vec2 particleUV = indexToUV( particleIndex, resolution );
    vec3 particleForce = texture2D( particleForceTex, particleUV ).xyz;
    vBodyForce = particleForce;
    vec2 bodyUV = indexToUV( bodyIndex, bodyTextureResolution );
    bodyUV += vec2(0.5) / bodyTextureResolution;// center to pixel
    gl_PointSize = 1.0;
    gl_Position = vec4(2.0 * (bodyUV - 0.5), 0, 1);
}
</script>
<script id="addParticleTorqueToBodyVert" type="x-shader/x-vertex">
uniform sampler2D relativeParticlePosTex;
uniform sampler2D particleForceTex;
attribute float particleIndex;
attribute float bodyIndex; // Should this be in a texture?
varying vec3 vBodyForce;
void main() {
    vec2 particleUV = indexToUV( particleIndex, resolution );
    vec3 particleForce = texture2D( particleForceTex, particleUV ).xyz;
    vec3 relativeParticlePos = texture2D( relativeParticlePosTex, particleUV ).xyz;
    vBodyForce = cross(relativeParticlePos, particleForce);
    vec2 bodyUV = indexToUV( bodyIndex, bodyTextureResolution );
    bodyUV += vec2(0.5) / bodyTextureResolution;// center to pixel
    gl_PointSize = 1.0;
    gl_Position = vec4(2.0 * (bodyUV - 0.5), 0, 1);
}
</script>
<script id="addParticleForceToBodyFrag" type="x-shader/x-fragment">
varying vec3 vBodyForce;
void main() {
   gl_FragColor = vec4(vBodyForce, 0.0);
}
</script>


<!-- transform body-local particle positions to world, relative to the body -->
<script id="localParticlePositionToRelativeFrag" type="x-shader/x-fragment">
uniform sampler2D localParticlePosTex;
uniform sampler2D bodyPosTex;
uniform sampler2D bodyQuatTex;
void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    float particleIndex = uvToIndex(uv, resolution);
    vec4 particlePosAndBodyId = texture2D( localParticlePosTex, uv );
    vec3 particlePos = particlePosAndBodyId.xyz;
    float bodyIndex = particlePosAndBodyId.w;
    vec2 bodyUV = indexToUV( bodyIndex, bodyTextureResolution );
    bodyUV += vec2(0.5) / bodyTextureResolution;// center to pixel
    vec3 bodyQuat = texture2D( bodyQuatTex, bodyUV );
    vec2 particleUV = indexToUV( particleIndex, resolution );

    vec3 relativeParticlePos = vec3_applyQuat(particlePos, bodyQuat);

    gl_FragColor = vec4(relativeParticlePos, bodyIndex);
}
</script>

<!-- transform body-local particle positions to world -->
<script id="localParticlePositionToWorldFrag" type="x-shader/x-fragment">
uniform sampler2D relativeParticlePosTex;
uniform sampler2D bodyPosTex;
void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    float particleIndex = uvToIndex(uv, resolution);
    vec4 particlePosAndBodyId = texture2D( relativeParticlePosTex, uv );
    vec3 particlePos = particlePosAndBodyId.xyz;

    float bodyIndex = particlePosAndBodyId.w;
    vec2 bodyUV = indexToUV( bodyIndex, bodyTextureResolution );
    bodyUV += vec2(0.5) / bodyTextureResolution; // center to pixel
    vec4 bodyPos = texture2D( bodyPosTex, bodyUV );

    vec3 worldParticlePos = vec3_applyQuat(particlePos, bodyQuat) + bodyPos;
    gl_FragColor = vec4(worldParticlePos, bodyIndex);
}
</script>


<!-- transform body velocity to particle velocity -->
<script id="bodyVelocityToParticleVelocityFrag" type="x-shader/x-fragment">
uniform sampler2D relativeParticlePosTex;
uniform sampler2D bodyVelTex;
uniform sampler2D bodyAngularVelTex;
void main() {
    vec2 particleUV = gl_FragCoord.xy / resolution;
    vec4 particlePosAndBodyId = texture2D( relativeParticlePosTex, particleUV );
    vec3 relativeParticlePosTex = particlePosAndBodyId.xyz;
    float bodyIndex = particlePosAndBodyId.w;
    vec2 bodyUV = indexToUV( bodyIndex, bodyTextureResolution );
    bodyUV += vec2(0.5) / bodyTextureResolution;// center to pixel

    vec4 bodyVelocity = texture2D( bodyVelTex, bodyUV );
    vec4 bodyAngularVelocity = texture2D( bodyAngularVelTex, bodyUV );
    vec3 particleVelocity = bodyVelocity + cross(relativeParticlePosition, bodyAngularVelocity);

    gl_FragColor = vec4(particleVelocity, 1);
}
</script>



<script src="three.orbitcontrols.js"></script>
<script src="main.js"></script>
</body>
</html>